<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Variable Manager</title>
    <style>
        /* Only essential functional styles that figui3 doesn't provide */
        .hidden {
            display: none;
        }

        /* Tab switching functionality - required for our custom tabs */
        .tab-panel {
            display: none;
        }

        .tab-panel.active {
            display: block;
        }
        
        /* Minimal spacing between form elements */
        .form-field + .form-field {
            margin-top: 1rem;
        }
    </style>
</head>
<body>
    <h3>Variable Manager</h3>
    
    <!-- Correct figui3 Tab Structure: Navigation separate from content -->
    <fig-tabs id="main-tabs">
        <fig-tab data-tab="create" selected>Create Swatches</fig-tab>
        <fig-tab data-tab="export">Export Variables</fig-tab>
        <fig-tab data-tab="update">Update</fig-tab>
    </fig-tabs>
    
    <!-- Tab Content Panels -->
    <div class="tab-content">
        <!-- Create Swatches Panel -->
        <div class="tab-panel active" id="panel-create">
            <fig-field class="form-field">
                <label for="collection-select-create">Variable Collection</label>
                <select id="collection-select-create">
                    <option>Select a variable collection...</option>
                </select>
            </fig-field>

            <fig-button id="create" type="primary" disabled>Create Color Swatches</fig-button>
            
            <div class="help-text">
                Creates visual swatch components from your color variables. Requires a "color swatch" component in your file.
            </div>
        </div>
        
        <!-- Export Variables Panel -->
        <div class="tab-panel" id="panel-export">
            <fig-field class="form-field">
                <label for="collection-select-export">Variable Collection</label>
                <select id="collection-select-export">
                    <option>Select a variable collection...</option>
                </select>
            </fig-field>

            <fig-field class="form-field">
                <label>Format</label>
                <fig-radio name="format" value="css" id="format-css" checked>CSS Custom Properties</fig-radio>
                <fig-radio name="format" value="json" id="format-json">JSON</fig-radio>
                <fig-radio name="format" value="tokens" id="format-tokens">Design Tokens</fig-radio>
            </fig-field>

            <fig-button id="export" type="secondary" disabled>Export Collection</fig-button>
            
            <div class="help-text">
                Export color variables in multiple formats for use in code or design tokens.
            </div>
        </div>
        
        <!-- Update Variables Panel -->
        <div class="tab-panel" id="panel-update">
            <fig-field class="form-field">
                <label for="collection-select-update">Variable Collection</label>
                <select id="collection-select-update">
                    <option>Select a variable collection...</option>
                </select>
            </fig-field>

            <!-- Dynamic mode selection - populated based on collection and JSON analysis -->
            <fig-field id="mode-selection" class="hidden form-field">
                <label id="mode-selection-label">Select Mode</label>
                <div id="mode-radio-group">
                    <!-- Radio buttons will be dynamically populated -->
                </div>
            </fig-field>

            <fig-field class="form-field">
                <label for="update-data">Design Tokens JSON</label>
                <textarea id="update-data" placeholder="Paste Leonardo or Design Tokens JSON here..."></textarea>
            </fig-field>
            
            <fig-button id="analyze" type="primary" disabled>Analyze Variables</fig-button>
            
            <div class="help-text">
                Paste flat design tokens (like from Leonardo) to update your selected collection. Only color scale tokens (e.g., "Red100", "Blue500") will be mapped - special tokens like "Background" are ignored. If the collection has multiple modes, choose which one to update.
            </div>

            <!-- Mapping Preview Section (hidden by default) -->
            <div id="mapping-preview" class="hidden">
                <label>üìã Mapping Preview</label>
                
                <div id="mapping-info">
                    <!-- Will be populated with mapping details -->
                </div>
                
                <div id="mapping-samples">
                    <!-- Will show sample mappings -->
                </div>
                
                <fig-button id="apply-updates" type="primary">Apply Updates</fig-button>
                <fig-button id="cancel-updates" type="secondary">Cancel</fig-button>
            </div>
        </div>
    </div>

    <div id="export-result" class="hidden">
        <label for="export-data">Exported Data</label>
        <textarea id="export-data" readonly placeholder="Exported data will appear here..."></textarea>
        <div class="help-text">Select all (‚åòA) and copy (‚åòC) the text above.</div>
        <fig-button class="btn-ghost" id="close-result">Close</fig-button>
    </div>

    <script>
        // Plugin state
        let selectedCollectionId = '';
        let collections = [];
        let uiConfig = null;
        let collectionModes = []; // Modes from selected Figma collection
        let requiresModeSelection = false;
        
        // Mapping data for updates
        let currentMappingData = null; // Store the mapping data from analysis

        // DOM elements
        const collectionSelectCreate = document.getElementById('collection-select-create');
        const collectionSelectExport = document.getElementById('collection-select-export');
        const collectionSelectUpdate = document.getElementById('collection-select-update');
        const createButton = document.getElementById('create');
        const exportButton = document.getElementById('export');
        const analyzeButton = document.getElementById('analyze');
        const updateDataTextarea = document.getElementById('update-data');
        const modeSelectionDiv = document.getElementById('mode-selection');
        const modeSelectionLabel = document.getElementById('mode-selection-label');
        const modeRadioGroup = document.getElementById('mode-radio-group');
        const mappingPreviewDiv = document.getElementById('mapping-preview');
        const mappingInfoDiv = document.getElementById('mapping-info');
        const mappingSamplesDiv = document.getElementById('mapping-samples');
        const applyUpdatesButton = document.getElementById('apply-updates');
        const cancelUpdatesButton = document.getElementById('cancel-updates');
        const exportResultDiv = document.getElementById('export-result');
        const exportDataTextarea = document.getElementById('export-data');
        const closeResultButton = document.getElementById('close-result');

        // Tab switching: Connect figui3 tabs to content panels
        function initializeTabSwitching() {
            const tabsContainer = document.querySelector('fig-tabs');
            const panels = document.querySelectorAll('.tab-panel');
            
            if (!tabsContainer) {
                console.error('‚ùå fig-tabs container not found');
                return;
            }
            
            // Listen for clicks on fig-tab elements
            tabsContainer.addEventListener('click', (e) => {
                if (e.target.tagName.toLowerCase() === 'fig-tab') {
                    const targetTab = e.target.getAttribute('data-tab');
                    if (!targetTab) return;
                    
                    // Hide all panels
                    panels.forEach(panel => panel.classList.remove('active'));
                    
                    // Show the target panel
                    const targetPanel = document.getElementById(`panel-${targetTab}`);
                    if (targetPanel) {
                        targetPanel.classList.add('active');
                        console.log(`‚úÖ Switched to ${targetTab} tab`);
                    } else {
                        console.error(`‚ùå Panel panel-${targetTab} not found`);
                    }
                }
            });
            
            console.log('‚úÖ Tab switching initialized');
        }

        // UI resize utility functions
        function requestUIResize(width, height) {
            parent.postMessage({
                pluginMessage: {
                    type: 'resize-ui',
                    width: width,
                    height: height
                }
            }, '*');
        }

        function resizeToCompact() {
            if (uiConfig) {
                requestUIResize(uiConfig.width.default, uiConfig.height.compact);
            }
        }

        function resizeToExpanded() {
            if (uiConfig) {
                requestUIResize(uiConfig.width.default, uiConfig.height.expanded);
            }
        }

        // Collection selection handler
        function handleCollectionChange(selectedValue) {
            if (selectedValue && selectedValue !== 'Select a variable collection...') {
                selectedCollectionId = selectedValue;
                createButton.disabled = false;
                exportButton.disabled = false;
                updateModeSelection(); // Trigger smart mode analysis
            } else {
                selectedCollectionId = '';
                createButton.disabled = true;
                exportButton.disabled = true;
                analyzeButton.setAttribute('disabled', 'true');
                hideModeSelection();
            }
        }

        function updateAnalyzeButtonState() {
            const hasCollection = selectedCollectionId && selectedCollectionId !== 'Select a variable collection...';
            const hasData = updateDataTextarea.value.trim().length > 0;
            const hasModeSelection = !requiresModeSelection || document.querySelector('fig-radio[name="mode-selection"] input:checked');
            
            const shouldEnable = hasCollection && hasData && hasModeSelection;
            
            if (shouldEnable) {
                analyzeButton.removeAttribute('disabled');
            } else {
                analyzeButton.setAttribute('disabled', 'true');
            }
        }

        // Extract source name from JSON (for display purposes)
        function getJsonSourceName(jsonString) {
            try {
                const parsed = JSON.parse(jsonString);
                const rootKeys = Object.keys(parsed);
                
                // If there's one main key, use that as the source name
                if (rootKeys.length === 1) {
                    return rootKeys[0];
                }
                
                // Otherwise use generic name
                return 'Pasted Tokens';
                
            } catch (error) {
                console.warn('Failed to parse JSON for source name:', error);
                return 'Invalid JSON';
            }
        }

        // Show/hide and populate mode selection UI - handles all JSON/Figma mode combinations
        function updateModeSelection() {
            const selectedCollection = collections.find(c => c.id === selectedCollectionId);
            const jsonContent = updateDataTextarea.value.trim();
            
            if (!selectedCollection || !jsonContent) {
                console.log('‚ùå Missing collection or JSON, hiding mode selection');
                hideModeSelection();
                return;
            }
            
            // Analyze JSON structure
            let jsonAnalysis = null;
            try {
                const parsedJson = JSON.parse(jsonContent);
                jsonAnalysis = analyzeJsonModes(parsedJson);
            } catch (error) {
                console.log('‚ùå Invalid JSON, hiding mode selection');
                hideModeSelection();
                return;
            }
            
            collectionModes = selectedCollection.modes || [];
            const figmaHasModes = collectionModes.length > 1;
            
            console.log('üéõÔ∏è Mode analysis:', {
                collectionName: selectedCollection.name,
                figmaHasModes,
                figmaModesCount: collectionModes.length,
                figmaModeNames: collectionModes.map(m => m.name),
                jsonHasModes: jsonAnalysis.hasModes,
                jsonModes: jsonAnalysis.modes,
                jsonSourceName: jsonAnalysis.name
            });
            
            // Determine what UI to show based on mode combinations
            console.log('üîß updateModeSelection: Decision logic:', {
                jsonHasModes: jsonAnalysis.hasModes,
                figmaHasModes: figmaHasModes,
                originalLogic: jsonAnalysis.hasModes || figmaHasModes
            });
            
            // ALWAYS show mode selection when JSON is provided - assume path-based themes (light/dark)
            // Even if Figma has only 1 mode, the variables likely have /light/ and /dark/ paths
            console.log('üîß updateModeSelection: JSON detected, always showing theme selection');
            showModeSelection(selectedCollection.name, jsonAnalysis);
        }

        // Analyze JSON to detect modes (client-side version of the main.ts function)
        function analyzeJsonModes(tokensData) {
            const rootKeys = Object.keys(tokensData);
            let name = 'Pasted Tokens';
            let hasModes = false;
            let modes = [];
            
            if (rootKeys.length === 1) {
                name = rootKeys[0];
                const mainObj = tokensData[name];
                
                if (typeof mainObj === 'object' && mainObj !== null) {
                    const topLevelKeys = Object.keys(mainObj);
                    
                    if (topLevelKeys.length > 0) {
                        const firstItem = mainObj[topLevelKeys[0]];
                        if (typeof firstItem === 'object' && firstItem !== null) {
                            const firstItemKeys = Object.keys(firstItem);
                            
                            // Check if this is a combined color+scale structure (like "Red100", "Blue500")
                            const hasTokenStructure = firstItemKeys.includes('value') && firstItemKeys.includes('type');
                            
                            if (hasTokenStructure) {
                                // This is a flat token structure - no modes
                                hasModes = false;
                            } else {
                                const numericKeys = firstItemKeys.filter(k => !isNaN(parseInt(k))).length;
                                const nonNumericKeys = firstItemKeys.filter(k => isNaN(parseInt(k))).length;
                                
                                if (nonNumericKeys > numericKeys && nonNumericKeys > 0) {
                                    // Has modes
                                    hasModes = true;
                                    modes = topLevelKeys;
                                }
                            }
                        }
                    }
                }
            }
            
            return { name, hasModes, modes };
        }

        function showModeSelection(collectionName, jsonAnalysis) {
            console.log('üîß showModeSelection called:', { 
                collectionName, 
                jsonAnalysis, 
                figmaModesCount: collectionModes.length 
            });
            
            requiresModeSelection = true;
            modeSelectionDiv.classList.remove('hidden');
            
            // Determine the appropriate UI based on mode combinations
            const figmaHasModes = collectionModes.length > 1;
            const jsonHasModes = jsonAnalysis.hasModes;
            
            let labelText = '';
            let options = [];
            
            if (jsonHasModes && figmaHasModes) {
                // Both have modes - need to map JSON mode to Figma mode
                labelText = `Map ${jsonAnalysis.name} modes to ${collectionName} modes`;
                // For now, show Figma modes (TODO: enhance to show JSON‚ÜíFigma mapping)
                options = collectionModes.map(mode => ({
                    value: mode.name,
                    label: `Update ${mode.name} mode`,
                    id: mode.id
                }));
            } else if (jsonHasModes && !figmaHasModes) {
                // JSON has modes, Figma is single mode - choose which JSON mode to use
                labelText = `Select ${jsonAnalysis.name} mode to update ${collectionName}`;
                options = jsonAnalysis.modes.map(mode => ({
                    value: mode,
                    label: `Use ${mode} mode`,
                    id: mode
                }));
            } else if (!jsonHasModes && figmaHasModes) {
                // JSON is flat, Figma has modes - provide light/dark theme options
                labelText = `Update ${collectionName} with ${jsonAnalysis.name}`;
                console.log('üîß UI: JSON is flat, Figma has modes - providing light/dark theme options');
                options = [
                    { value: 'light', label: 'Update light theme', id: 'light' },
                    { value: 'dark', label: 'Update dark theme', id: 'dark' }
                ];
                console.log('üîß UI: Set options to light/dark themes:', options);
            } else if (!jsonHasModes && !figmaHasModes) {
                // JSON is flat, Figma has single mode - STILL provide light/dark theme options
                labelText = `Update ${collectionName} with ${jsonAnalysis.name}`;
                console.log('üîß UI: JSON is flat, Figma single mode - providing light/dark theme options');
                options = [
                    { value: 'light', label: 'Update light theme', id: 'light' },
                    { value: 'dark', label: 'Update dark theme', id: 'dark' }
                ];
                console.log('üîß UI: Set options to light/dark themes:', options);
            }
            
            modeSelectionLabel.textContent = labelText;
            
            // Populate radio buttons using fig-radio
            modeRadioGroup.innerHTML = '';
            options.forEach((option, index) => {
                const radioElement = document.createElement('fig-radio');
                radioElement.setAttribute('name', 'mode-selection');
                radioElement.setAttribute('value', option.value);
                radioElement.textContent = option.label;
                if (index === 0) {
                    radioElement.setAttribute('checked', '');
                }
                modeRadioGroup.appendChild(radioElement);
            });
            
            // Add event listeners to fig-radio internal inputs
            requestAnimationFrame(() => {
                const radioInputs = modeRadioGroup.querySelectorAll('fig-radio input');
                console.log('üîß Attached event listeners to', radioInputs.length, 'radio inputs');
                radioInputs.forEach(radio => {
                    radio.addEventListener('change', updateAnalyzeButtonState);
                });
            });
            
            updateAnalyzeButtonState();
        }

        function hideModeSelection() {
            console.log('üôà hideModeSelection called');
            requiresModeSelection = false;
            modeSelectionDiv.classList.add('hidden');
            updateAnalyzeButtonState();
        }

        // Populate all collections dropdowns
        function populateCollections(collectionsData) {
            collections = collectionsData;
            const defaultOption = '<option>Select a variable collection...</option>';
            
            collectionSelectCreate.innerHTML = defaultOption;
            collectionSelectExport.innerHTML = defaultOption;
            collectionSelectUpdate.innerHTML = defaultOption;

            if (collections.length === 0) {
                const emptyOption = '<option disabled>No variable collections found</option>';
                collectionSelectCreate.innerHTML += emptyOption;
                collectionSelectExport.innerHTML += emptyOption;
                collectionSelectUpdate.innerHTML += emptyOption;
            } else {
                let optionsHTML = '';
                collections.forEach(collection => {
                    optionsHTML += `<option value="${collection.id}">${collection.name}</option>`;
                });
                collectionSelectCreate.innerHTML += optionsHTML;
                collectionSelectExport.innerHTML += optionsHTML;
                collectionSelectUpdate.innerHTML += optionsHTML;
            }
        }

        // Sync collection selectors - when one changes, update all others
        function syncCollectionSelectors(sourceSelector, value) {
            const allSelectors = [collectionSelectCreate, collectionSelectExport, collectionSelectUpdate];
            allSelectors.forEach(selector => {
                if (selector !== sourceSelector && selector.value !== value) {
                    selector.value = value;
                }
            });
        }

        // Handle messages from plugin
        onmessage = event => {
            const msg = event.data.pluginMessage;

            if (msg.type === 'collections') {
                populateCollections(msg.collections);
                // Store UI configuration for responsive sizing
                if (msg.uiConfig) {
                    uiConfig = msg.uiConfig;
                }
            } else if (msg.type === 'exported') {
                exportDataTextarea.value = msg.data;
                exportResultDiv.classList.remove('hidden');
                exportDataTextarea.focus();
                exportDataTextarea.select();
                // Resize to expanded view to accommodate export results
                resizeToExpanded();
            } else if (msg.type === 'mapping-preview') {
                showMappingPreview(msg.preview);
            } else if (msg.type === 'update-complete') {
                hideMappingPreview();
                alert('‚úÖ Variables updated successfully!');
            } else if (msg.type === 'error') {
                alert('‚ùå Error: ' + msg.message);
            }
        };
        
        function showMappingPreview(preview) {
            // Store mapping data for applying updates
            currentMappingData = preview;
            
            // Hide the input form and show mapping preview
            const collectionField = document.querySelector('#panel-update label[for="collection-select-update"]')?.closest('fig-field');
            const dataField = document.querySelector('#panel-update label[for="update-data"]')?.closest('fig-field');
            const helpText = document.querySelector('#panel-update .help-text');
            
            if (collectionField) collectionField.style.display = 'none';
            modeSelectionDiv.style.display = 'none';
            if (dataField) dataField.style.display = 'none';
            analyzeButton.style.display = 'none';
            if (helpText) helpText.style.display = 'none';
            
            // Populate mapping info
            mappingInfoDiv.innerHTML = `
                <div><strong>Source JSON:</strong> ${preview.sourceName} (flat token structure)</div>
                <div><strong>Destination:</strong> ${preview.destinationName} ‚Üí ${preview.targetMode} mode</div>
                <div><strong>Scale Mapping:</strong> ${preview.sourceScale} ‚Üí ${preview.destinationScale}</div>
                <div><strong>Colors Found:</strong> ${preview.colorCount} color families</div>
                <div style="margin-top: 8px; padding: 8px; background: #f0f7ff; border-left: 4px solid #0066cc; border-radius: 4px; font-size: 12px;">
                    <strong>üìã What will happen:</strong> Your JSON color scale tokens (like "Red500", "Blue100") will update matching Figma variables by color name and scale position. Special tokens like "Background" are excluded.
                </div>
            `;
            
            // Populate mapping samples
            mappingSamplesDiv.innerHTML = `
                <label>Sample Mappings (${preview.samples.length} total):</label>
                <div style="font-family: monospace; font-size: 11px; background: #f9f9f9; padding: 8px; border-radius: 4px; margin-top: 4px; max-height: 300px; overflow-y: auto;">
                    ${preview.samples.map(sample => 
                        `<div style="margin-bottom: 2px; display: flex; justify-content: space-between;">
                            <span style="color: #666;">${sample.from}</span>
                            <span style="margin: 0 8px;">‚Üí</span>
                            <span style="color: #333; font-weight: 500;">${sample.to}</span>
                        </div>`
                    ).join('')}
                </div>
            `;
            
            // Show mapping preview section
            mappingPreviewDiv.classList.remove('hidden');
            
            // Resize to expanded view
            resizeToExpanded();
        }
        
        function hideMappingPreview() {
            // Show the input form again
            const collectionField = document.querySelector('#panel-update label[for="collection-select-update"]')?.closest('fig-field');
            const dataField = document.querySelector('#panel-update label[for="update-data"]')?.closest('fig-field');
            const helpText = document.querySelector('#panel-update .help-text');
            
            if (collectionField) collectionField.style.display = 'block';
            if (!modeSelectionDiv.classList.contains('hidden')) {
                modeSelectionDiv.style.display = 'block';
            }
            if (dataField) dataField.style.display = 'block';
            analyzeButton.style.display = 'block';
            if (helpText) helpText.style.display = 'block';
            
            // Hide mapping preview section
            mappingPreviewDiv.classList.add('hidden');
            
            // Clear mapping data
            currentMappingData = null;
            
            // Clear textarea and reset button states
            updateDataTextarea.value = '';
            updateModeSelection();
            
            // Resize back to compact view
            resizeToCompact();
        }

        // Test: Verify figui3 JavaScript is loaded and working (console only)
        function testFigui3Integration() {
            console.log('üß™ Testing figui3 integration...');
            
            // Test 1: Check if customElements API is available
            if (typeof customElements === 'undefined') {
                console.error('‚ùå customElements API not available');
                return false;
            }
            console.log('‚úÖ customElements API available');
            
            // Test 2: Check if fig-tabs is registered
            try {
                const testTab = document.createElement('fig-tab');
                if (testTab instanceof HTMLElement) {
                    console.log('‚úÖ fig-tab element can be created');
                } else {
                    console.error('‚ùå fig-tab element creation failed');
                    return false;
                }
            } catch (e) {
                console.error('‚ùå Error creating fig-tab:', e);
                return false;
            }
            
            // Test 3: Check if our actual fig-tabs element exists and has the right structure
            const figTabsElement = document.querySelector('fig-tabs');
            if (figTabsElement) {
                console.log('‚úÖ fig-tabs element found in DOM');
                const figTabElements = figTabsElement.querySelectorAll('fig-tab');
                console.log(`‚úÖ Found ${figTabElements.length} fig-tab elements`);
                
                // Test tabs have proper data attributes
                figTabElements.forEach((tab, index) => {
                    const tabName = tab.textContent.trim();
                    const dataTab = tab.getAttribute('data-tab');
                    console.log(`üìã Tab ${index + 1}: "${tabName}" (data-tab: ${dataTab})`);
                });
                
                // Test 4: Check if content panels exist
                const panels = document.querySelectorAll('.tab-panel');
                console.log(`‚úÖ Found ${panels.length} content panels`);
                panels.forEach((panel, index) => {
                    const isActive = panel.classList.contains('active');
                    console.log(`üìã Panel ${index + 1}: ${panel.id} (active: ${isActive})`);
                });
                
            } else {
                console.error('‚ùå fig-tabs element not found in DOM');
                return false;
            }
            
            console.log('üéâ figui3 integration test completed successfully!');
            return true;
        }

        // Initialize everything when DOM is ready
        function initializeAll() {
            testFigui3Integration();
            initializeTabSwitching();
            attachEventListeners();
        }

        // Attach all event listeners
        function attachEventListeners() {
            // Collection dropdown change handlers
            if (collectionSelectCreate) {
                collectionSelectCreate.addEventListener('change', (e) => {
                    const value = e.target.value;
                    handleCollectionChange(value);
                    syncCollectionSelectors(collectionSelectCreate, value);
                });
            }

            if (collectionSelectExport) {
                collectionSelectExport.addEventListener('change', (e) => {
                    const value = e.target.value;
                    handleCollectionChange(value);
                    syncCollectionSelectors(collectionSelectExport, value);
                });
            }

            if (collectionSelectUpdate) {
                collectionSelectUpdate.addEventListener('change', (e) => {
                    const value = e.target.value;
                    handleCollectionChange(value);
                    syncCollectionSelectors(collectionSelectUpdate, value);
                });
            }

            // Update tab event listeners
            if (updateDataTextarea) {
                updateDataTextarea.addEventListener('input', () => {
                    updateModeSelection(); // Trigger smart mode analysis when JSON changes
                });
            }

            // Analyze button
            if (analyzeButton) {
                analyzeButton.addEventListener('click', () => {
                    if (selectedCollectionId && updateDataTextarea.value.trim()) {
                        let targetMode = null;
                        
                        console.log('üîß UI: Analyzing with requiresModeSelection =', requiresModeSelection);
                        console.log('üîß UI: collectionModes.length =', collectionModes.length);
                        
                        if (requiresModeSelection) {
                            const selectedRadio = document.querySelector('fig-radio[name="mode-selection"] input:checked');
                            targetMode = selectedRadio ? selectedRadio.value : null;
                            console.log('üîß UI: Selected radio value:', targetMode);
                        } else {
                            // No mode selection needed - default to light theme
                            targetMode = 'light';
                            console.log('üîß UI: No mode selection, defaulting to:', targetMode);
                        }
                        
                        try {
                            const tokensData = JSON.parse(updateDataTextarea.value.trim());
                            
                            parent.postMessage({
                                pluginMessage: {
                                    type: 'analyze-tokens',
                                    collectionId: selectedCollectionId,
                                    targetMode: targetMode,
                                    tokensData: tokensData
                                }
                            }, '*');
                            
                            console.log('üîç Sent analyze request to main thread');
                            console.log('Collection:', selectedCollectionId);
                            console.log('Target mode:', targetMode);
                            
                        } catch (error) {
                            alert('Invalid JSON format. Please check your pasted data.');
                        }
                    }
                });
            }

            // Button click handlers
            if (createButton) {
                createButton.addEventListener('click', () => {
                    if (selectedCollectionId) {
                        parent.postMessage({
                            pluginMessage: { type: 'create-swatches', collectionId: selectedCollectionId }
                        }, '*');
                    }
                });
            }

            if (exportButton) {
                exportButton.addEventListener('click', () => {
                    if (selectedCollectionId) {
                        parent.postMessage({
                            pluginMessage: { type: 'export-collection', collectionId: selectedCollectionId }
                        }, '*');
                    }
                });
            }

            // Close result button
            if (closeResultButton) {
                closeResultButton.addEventListener('click', () => {
                    if (exportResultDiv) {
                        exportResultDiv.classList.add('hidden');
                        resizeToCompact();
                    }
                });
            }

            // Apply Updates button
            if (applyUpdatesButton) {
                applyUpdatesButton.addEventListener('click', () => {
                    if (!selectedCollectionId || !currentMappingData) {
                        alert('No mapping data available');
                        return;
                    }
                    
                    // Get the currently selected theme (light or dark) from the radio buttons
                    let selectedTheme = null;
                    if (requiresModeSelection) {
                        const selectedRadio = document.querySelector('fig-radio[name="mode-selection"] input:checked');
                        selectedTheme = selectedRadio ? selectedRadio.value : null;
                    } else {
                        // If no mode selection was shown, default to light theme
                        selectedTheme = 'light';
                    }
                    
                    console.log('üîÑ Apply Updates - Selected theme:', selectedTheme);
                    
                    try {
                        parent.postMessage({
                            pluginMessage: {
                                type: 'apply-updates',
                                collectionId: selectedCollectionId,
                                targetMode: selectedTheme, // Send the selected theme (light/dark)
                                tokensData: JSON.parse(updateDataTextarea.value.trim()),
                                mappingData: currentMappingData
                            }
                        }, '*');
                        
                        console.log('üîÑ Apply Updates message sent:', {
                            targetMode: selectedTheme,
                            collectionId: selectedCollectionId
                        });
                        
                    } catch (error) {
                        alert('Error applying updates: ' + error.message);
                    }
                });
            }

            // Cancel Updates button
            if (cancelUpdatesButton) {
                cancelUpdatesButton.addEventListener('click', () => {
                    hideMappingPreview();
                });
            }
        }
        
        // Message handler for communication with main thread
        window.onmessage = (event) => {
            const msg = event.data.pluginMessage;
            if (!msg) return;

            if (msg.type === 'collections') {
                collections = msg.collections || [];
                uiConfig = msg.uiConfig;
                
                // Populate all dropdowns
                populateCollectionDropdown(collectionSelectCreate);
                populateCollectionDropdown(collectionSelectExport);
                populateCollectionDropdown(collectionSelectUpdate);
            } else if (msg.type === 'export-complete') {
                showExportResult(msg.data, msg.format);
            } else if (msg.type === 'mapping-preview') {
                showMappingPreview(msg.preview);
            } else if (msg.type === 'update-complete') {
                alert('‚úÖ Variables updated successfully!');
                hideMappingPreview();
            } else if (msg.type === 'error') {
                alert('‚ùå Error: ' + msg.message);
            }
        };

        function populateCollectionDropdown(selectElement) {
            if (!selectElement) return;
            
            // Clear existing options
            selectElement.innerHTML = '';
            
            // Add default option
            const defaultOption = document.createElement('option');
            defaultOption.value = '';
            defaultOption.textContent = 'Select a variable collection...';
            selectElement.appendChild(defaultOption);
            
            // Add collection options
            collections.forEach(collection => {
                const option = document.createElement('option');
                option.value = collection.id;
                option.textContent = collection.name;
                selectElement.appendChild(option);
            });
        }

        // Sync selection across all dropdowns
        function syncCollectionSelectors(sourceSelector, selectedValue) {
            const selectors = [collectionSelectCreate, collectionSelectExport, collectionSelectUpdate];
            
            selectors.forEach(selector => {
                if (selector && selector !== sourceSelector) {
                    selector.value = selectedValue;
                }
            });
        }

        function showExportResult(data, format) {
            const exportDataTextarea = document.getElementById('export-data');
            const exportResult = document.getElementById('export-result');
            
            if (exportDataTextarea) {
                exportDataTextarea.value = data;
            }
            
            if (exportResult) {
                exportResult.classList.remove('hidden');
                resizeToExpanded();
            }
        }

        function showMappingPreview(preview) {
            // Store mapping data for applying updates
            currentMappingData = preview;
            
            // Hide the input form and show mapping preview
            const collectionField = document.querySelector('#panel-update label[for="collection-select-update"]')?.closest('fig-field');
            const dataField = document.querySelector('#panel-update label[for="update-data"]')?.closest('fig-field');
            const helpText = document.querySelector('#panel-update .help-text');
            
            if (collectionField) collectionField.style.display = 'none';
            modeSelectionDiv.style.display = 'none';
            if (dataField) dataField.style.display = 'none';
            analyzeButton.style.display = 'none';
            if (helpText) helpText.style.display = 'none';
            
            // Populate mapping info
            const mappingInfoDiv = document.getElementById('mapping-info');
            if (mappingInfoDiv) {
                mappingInfoDiv.innerHTML = `
                    <div><strong>Source JSON:</strong> ${preview.sourceName} (flat token structure)</div>
                    <div><strong>Destination:</strong> ${preview.destinationName} ‚Üí ${preview.targetMode} mode</div>
                    <div><strong>Scale Mapping:</strong> ${preview.sourceScale} ‚Üí ${preview.destinationScale}</div>
                    <div><strong>Colors Found:</strong> ${preview.colorCount} color families</div>
                    <div style="margin-top: 8px; padding: 8px; background: #f0f7ff; border-left: 4px solid #0066cc; border-radius: 4px; font-size: 12px;">
                        <strong>üìã What will happen:</strong> Your JSON color scale tokens (like "Red500", "Blue100") will update matching Figma variables by color name and scale position. Special tokens like "Background" are excluded.
                    </div>
                `;
            }
            
            // Populate mapping samples
            const mappingSamplesDiv = document.getElementById('mapping-samples');
            if (mappingSamplesDiv) {
                mappingSamplesDiv.innerHTML = `
                    <label>Sample Mappings (${preview.samples.length} total):</label>
                    <div style="font-family: monospace; font-size: 11px; background: #f9f9f9; padding: 8px; border-radius: 4px; margin-top: 4px; max-height: 300px; overflow-y: auto;">
                        ${preview.samples.map(sample => 
                            `<div style="margin-bottom: 2px; display: flex; justify-content: space-between;">
                                <span style="color: #666;">${sample.from}</span>
                                <span style="margin: 0 8px;">‚Üí</span>
                                <span style="color: #333; font-weight: 500;">${sample.to}</span>
                            </div>`
                        ).join('')}
                    </div>
                `;
            }
            
            // Show mapping preview section
            const mappingPreviewDiv = document.getElementById('mapping-preview');
            if (mappingPreviewDiv) {
                mappingPreviewDiv.classList.remove('hidden');
            }
            
            // Resize to expanded view
            resizeToExpanded();
        }

        function hideMappingPreview() {
            // Show the input form and hide mapping preview
            const collectionField = document.querySelector('#panel-update label[for="collection-select-update"]')?.closest('fig-field');
            const dataField = document.querySelector('#panel-update label[for="update-data"]')?.closest('fig-field');
            const helpText = document.querySelector('#panel-update .help-text');
            
            if (collectionField) collectionField.style.display = '';
            modeSelectionDiv.style.display = '';
            if (dataField) dataField.style.display = '';
            analyzeButton.style.display = '';
            if (helpText) helpText.style.display = '';
            
            // Hide mapping preview section
            const mappingPreviewDiv = document.getElementById('mapping-preview');
            if (mappingPreviewDiv) {
                mappingPreviewDiv.classList.add('hidden');
            }
            
            // Clear textarea and reset button states
            updateDataTextarea.value = '';
            updateModeSelection();
            
            // Resize back to compact view
            resizeToCompact();
        }


        
        // Run initialization when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeAll);
        } else {
            initializeAll();
        }
    </script>
</body>
</html>